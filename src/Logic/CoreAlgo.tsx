/* eslint-disable no-throw-literal */
import {
	IWEEK_GLOBAL_Object,
	IActlistObj,
	callNodeType,
	argumentsQueue,
	blowoutFunction,
} from "../Interfaces/Interfaces";
import { PosType, TeacherType_nullValue } from "../types";
import { putHimAt } from "./Logic";
import { util, equals } from "./util";

function conflicts(
	...args:
		| [callNodeType]
		| [IActlistObj[], { Pos: PosType; m: number; teacher: string }]
) {
	if (args.length === 1) {
		const vertix = args[0];
		if (
			vertix.week.allClasses[vertix.m].l[vertix.Pos[0]][vertix.Pos[1]]
				.isCemented
		) {
			return true;
		}
		for (let i = 0; i < vertix.Pivots.length; i++) {
			if (
				equals(vertix.Pivots[i].Pos, vertix.Pos) &&
				vertix.Pivots[i].m === vertix.m
			) {
				return true;
			} else if (
				vertix.Pivots[i].teacher === vertix.teacher &&
				equals(vertix.Pivots[i].Pos, vertix.Pos)
			) {
				return true;
			}
		}
		let tmp: callNodeType | null;
		if (vertix.parent !== undefined) tmp = vertix.parent;
		else
			throw {
				...vertix,
				message: "Parent is undefined!",
				where: "in conflicts",
			};
		while (tmp !== null) {
			if (equals(tmp.Pos, vertix.Pos) && tmp.m === vertix.m) {
				return true;
			} else if (
				tmp.teacher === vertix.teacher &&
				equals(tmp.Pos, vertix.Pos)
			) {
				return true;
			}
			if (tmp.parent !== undefined) {
				tmp = tmp.parent;
			} else {
				throw {
					...tmp,
					message: "Parent is undefined!",
					where: "in conflicts",
				};
			}
		}
		return false;
	} else if (args.length === 2) {
		const base = args[0];
		const Step = args[1];
		for (let i = 0; i < base.length; i++) {
			if (equals(base[i].Pos, Step.Pos) && base[i].m === Step.m) {
				return true;
			} else if (
				base[i].teacher === Step.teacher &&
				equals(base[i].Pos, Step.Pos)
			) {
				return true;
			}
		}
		return false;
	}
}

function preStrictConflicts(vertix: callNodeType) {
	let tmp: callNodeType | null;
	if (
		vertix.week.allClasses[vertix.m].l[vertix.Pos[0]][vertix.Pos[1]]
			.isCemented
	) {
		return true;
	}
	if (vertix.parent !== undefined) tmp = vertix.parent;
	else throw { ...vertix, message: `Parent is undefined` };
	while (tmp !== null) {
		if (equals(tmp.Pos, vertix.Pos) && tmp.m === vertix.m) {
			return true;
		} else if (tmp.teacher === vertix.teacher) {
			return true;
		}
		if (tmp.parent !== undefined) tmp = tmp.parent;
	}
	return false;
}

const MAX_CALLS = 5;
let q: argumentsQueue = new argumentsQueue();

function enoughSolutions(
	week: IWEEK_GLOBAL_Object,
	justOne: boolean = false
): boolean {
	if (justOne) week.activateList.length > 1;
	return week.activateList.length > MAX_CALLS;
}
export function takeOneOffTheStack(vertix: callNodeType) {
	const debt = {
		...vertix.Pivots[vertix.Pivots.length - 1],
		parent: vertix,
		Pivots: [...vertix.Pivots],
	};
	debt.Pivots.pop();
	q.enqueue(debt);
}
/**
 * Schedule re calls in another Class to free up the vertix.Pos in the vertix.m Class
 * @param vertix Dummy vertix used for The Position [number,number] we need empty in next_m
 * @param AfterReChainNode This will be added to the call stack and will be executed after any vertix generated by this pivot call finds a solution
 */
export function pivotTo(
	vertix: callNodeType,
	visited: boolean[] = new Array(11).fill(false)
) {
	// should schedule the re calls to the queue
	if (vertix.pivotArgs === undefined) {
		throw { ...vertix, message: "call to pivotTo with missing pivotArgs" };
	} else if (!conflicts(vertix)) {
		const m = vertix.pivotArgs.next_m;
		if (visited[m] || visited[vertix.m]) {
			console.warn(`circular calls breaker used`);
			return;
		}
		visited[m] = true;
		visited[vertix.m] = true;
		const nextNode = vertix.pivotArgs.AfterReChainNode;
		const [X, Y] = vertix.Pos;
		const augmentedParent = vertix.pivotArgs.beforeReChainNode;
		const NewStack =
			vertix.pivotArgs.beforeReChainNode === null
				? [...vertix.Pivots]
				: [...vertix.pivotArgs.beforeReChainNode.Pivots];
		if (nextNode !== undefined) NewStack.push(nextNode);
		// const teachers = util.removed(vertix.week.allClasses[m].l[X][Y].Options, vertix.week.allClasses[m].l[X][Y].currentTeacher);
		const replacementTeachers = vertix.week.allClasses[m].l[X][Y].Options;
		const requirePivoting = replacementTeachers.filter(
			(replacementTeacher: string) => {
				if (
					replacementTeacher ===
					vertix.week.allClasses[m].l[X][Y].currentTeacher
				)
					return false;
				const s = util.situation(
					replacementTeacher,
					vertix.Pos,
					m,
					vertix.week
				);
				if (
					s.r === -1 ||
					(replacementTeacher ===
						vertix.week.allClasses[vertix.m].l[X][Y].currentTeacher &&
						s.r === vertix.m)
				) {
					q.enqueue({
						callTo: "re",
						parent: augmentedParent,
						teacher: replacementTeacher,
						Pos: vertix.Pos,
						m,
						week: vertix.week,
						cycleClosingParentName: replacementTeacher,
						Action: s.action,
						Pivots: [...NewStack],
					});
					return false;
				} else if (s.r === vertix.m) {
					return false;
				} else return true;
			}
		);
		if (replacementTeachers.length - requirePivoting.length >= 3)
			// doesn't require pivoting .length >=2
			return;
		requirePivoting.forEach((replacementTeacher): void => {
			const s = util.situation(
				replacementTeacher,
				vertix.Pos,
				m,
				vertix.week
			);
			pivotTo(
				{
					...vertix,
					Pivots: [...NewStack], // if augmentedParent is null [] would have got to the next gen
					callTo: "pivotTo",
					pivotArgs: {
						next_m: s.r,
						AfterReChainNode: {
							callTo: "re",
							parent: undefined,
							teacher: replacementTeacher,
							Pos: vertix.Pos,
							m,
							week: vertix.week,
							cycleClosingParentName: replacementTeacher,
							Action: s.action,
							Pivots: [...NewStack],
						},
						beforeReChainNode: augmentedParent,
					},
				},
				visited
			);
		});
	}
}
/**
 * back track and return the path to the root
 * @param vertix leaf
 */
export function backtrack(vertix: callNodeType): IActlistObj[] {
	let tmp: callNodeType | null = vertix;
	const solution: IActlistObj[] = [];
	while (tmp !== null) {
		solution.push({ teacher: tmp.teacher, Pos: tmp.Pos, m: tmp.m });
		if (tmp.parent === undefined) {
			throw { ...tmp, message: "parent undefined" };
		} else {
			tmp = tmp.parent;
		}
	}
	return solution;
}
/**
 *
 * @param vertix arguments for the pre call
 */
export function pre(vertix: callNodeType) {
	const teacher = vertix.teacher;
	const m = vertix.m;
	const week = vertix.week;
	const solutions = week.activateList;
	if (!conflicts(vertix)) {
		const edges: PosType[] =
			week.allClasses[m].teachers[teacher].periodsHere ||
			util.getHisActPeriods(week.allClasses[m], teacher);
		const q_lenBefore = q.length();
		const localQueue = new argumentsQueue();
		edges.forEach((edge) => {
			const [edgeX, edgeY] = edge;
			const teachers = week.allClasses[m].l[edgeX][edgeY].Options;
			teachers.forEach((t) => {
				if (t === teacher) return;
				const newNode: callNodeType = {
					teacher: t,
					Pos: edge,
					m,
					week,
					callTo: "nothing",
					parent: vertix,
					Pivots: [...vertix.Pivots],
				};
				if (preStrictConflicts(newNode)) return;
				const s = util.situation(t, edge, m, week);
				if (s.action === "shift" && s.r === -1) {
					// push to solutions
					if (newNode.Pivots.length !== 0) {
						takeOneOffTheStack(newNode);
					} else {
						solutions.push(backtrack(newNode));
					}
				} else if (s.action === "cycle" && s.r === -1) {
					newNode.callTo = "pre";
					q.enqueue(newNode);
				} else if (s.action === "cycle" && s.r !== -1) {
					localQueue.enqueue({
						...newNode,
						callTo: "pivotTo",
						pivotArgs: {
							next_m: s.r,
							AfterReChainNode: {
								...newNode,
								callTo: "pre",
								parent: undefined,
							},
							beforeReChainNode: vertix,
						},
					});
				} else if (s.action === "shift" && s.r !== -1) {
					localQueue.enqueue({
						...newNode,
						callTo: "pivotTo",
						pivotArgs: {
							next_m: s.r,
							beforeReChainNode: vertix,
							AfterReChainNode: newNode,
						},
					});
				}
			});
		});
		const q_lenAfter = q.length();
		if (q_lenAfter - q_lenBefore < 3) {
			while (localQueue.notEmpty()) {
				// q.enqueue(localQueue.front())
				localQueue.callFront(re, pre, pivotTo);
				localQueue.dequeue();
			}
		}
	}
}
/**
 * re Assumes that this step has r===-1
 * @param vertix
 * @returns
 */
export function re(vertix: callNodeType) {
	const Pos = vertix.Pos;
	const m = vertix.m;
	const Action = vertix.Action;
	const week = vertix.week;
	const teacher = vertix.teacher;
	const solutions = week.activateList;
	const Pivots = [...vertix.Pivots];
	const S = util.situation(teacher, Pos, m, week);
	const oldTeacher = S.currTeacher;
	if (vertix.teacher === oldTeacher) return;
	const cyclingActionSatisfied = (aboutToBeSquashed: string) => {
		if (Action === "cycle" && vertix.cycleClosingParentName === undefined) {
			throw {
				...vertix,
				message:
					"re is a cycle and the vertix.cycleClosingParentName is undefined!",
			};
		} else {
			return (
				Action === "cycle" &&
				vertix.cycleClosingParentName === aboutToBeSquashed
			);
		}
	};
	const localQueue = new argumentsQueue();
	const q_lenBefore = q.length();
	const madePivots: number = Pivots.length;
	if (!conflicts(vertix)) {
		if (
			((Action === "shift" && S.currTeacher === TeacherType_nullValue) ||
				cyclingActionSatisfied(S.currTeacher)) &&
			!conflicts(vertix)
		) {
			if (vertix.Pivots.length === 0) {
				solutions.push(backtrack(vertix));
			} else {
				// q.enqueue({...vertix.Pivots[vertix.Pivots.length-1] ,  parent: vertix})
				// vertix.Pivots.pop();
				takeOneOffTheStack(vertix);
			}
		} else {
			if (oldTeacher === TeacherType_nullValue) return;
			const edges: PosType[] = week.availables[oldTeacher].filter(
				(edge: PosType) => {
					let tmp: callNodeType | null = vertix;
					while (tmp !== null) {
						if (equals(tmp.Pos, edge)) return false;
						if (tmp.parent !== undefined) tmp = tmp.parent;
						// eslint-disable-next-line no-throw-literal
						else throw { ...tmp, message: "Parent is undefined!!" };
					}
					return true;
				}
			); // used Position filtered out
			edges.forEach((p): void => {
				const newSituation = util.situation(oldTeacher, p, m, week);
				const newNode: callNodeType = {
					teacher: oldTeacher,
					Pos: p,
					m,
					Pivots,
					week,
					parent: vertix,
					callTo: "nothing",
					cycleClosingParentName: vertix.cycleClosingParentName,
					Action,
				};
				if (
					((Action === "shift" &&
						newSituation.currTeacher === TeacherType_nullValue) ||
						cyclingActionSatisfied(newSituation.currTeacher)) &&
					newSituation.r === -1 &&
					!conflicts(newNode)
				) {
					if (newNode.Pivots.length === 0) {
						solutions.push(backtrack(newNode));
					} else {
						// q.enqueue({...vertix.Pivots[vertix.Pivots.length-1] ,  parent: vertix})
						// vertix.Pivots.pop();
						takeOneOffTheStack(newNode);
					}
				} else {
					if (newSituation.r === m) {
						// this condition should be equivilant to currentTeacher===oldTeacher
					} else if (newSituation.r === -1) {
						// this means that it's possible for the old teacher to be put in this Pos
						// but we still have to find a place to put the (current teacher at Pos1) in.
						q.enqueue({
							...newNode,
							callTo: "re",
						});
					} else {
						localQueue.enqueue({
							...newNode,
							callTo: "pivotTo",
							pivotArgs: {
								next_m: newSituation.r,
								beforeReChainNode: vertix,
								AfterReChainNode: {
									//<- re calls check if the called for is it self a solution
									...newNode,
									callTo: "re",
									parent: undefined,
								},
							},
						});
					}
				}
			});
		}
	}
	const q_lenAfter = q.length();
	if (q_lenAfter - q_lenBefore < 3 && madePivots < 3) {
		while (localQueue.notEmpty()) {
			// q.enqueue(localQueue.front())
			localQueue.callFront(re, pre, pivotTo);
			localQueue.dequeue();
		}
	}
}
const delegate = (
	teacher: string,
	Pos: PosType,
	m: number,
	week: IWEEK_GLOBAL_Object,
	justOne: boolean = false,
	blowout?: blowoutFunction
) => {
	const situationInt = util.situationInt;
	const S = util.situation(teacher, Pos, m, week);
	/**
	 * {teacher,Pos,m,week,parent:null,callTo:'nothing',Pivots:[]}
	 */
	const rootVertix: callNodeType = {
		teacher,
		Pos,
		m,
		week,
		parent: null,
		callTo: "nothing",
		Pivots: [],
	};
	const sit = situationInt(S);
	console.log(
		"" +
			JSON.stringify(Pos) +
			" # " +
			week.allClasses[m].Name +
			" # " +
			teacher +
			" -> " +
			sit
	);
	switch (sit) {
		case 1: // t==='' & r===-1 & a ==='shift'
			week.Swapping = false;
			putHimAt(week, m, teacher, Pos, "put");
			break;
		case 2: // t==='' & r!==-1 & a ==='shift'
			// Pivot
			q.enqueue({
				...rootVertix,
				pivotArgs: { next_m: S.r, beforeReChainNode: rootVertix },
				callTo: "pivotTo",
			});
			break;
		case 3: // t==='' & r===-1 & a ==='cycle'
			// pre(teacher,Pos,m,week,[])
			q.enqueue({ ...rootVertix, callTo: "pre" });
			break;
		case 4: // t==='' & r!==-1 & a ==='cycle'
			q.enqueue({
				...rootVertix,
				callTo: "pivotTo",
				pivotArgs: {
					next_m: S.r,
					AfterReChainNode: {
						...rootVertix,
						parent: undefined,
						callTo: "pre",
					},
					beforeReChainNode: null,
				},
			});
			break;
		case 5: // t!=='' & r===-1 & a ==='shift'
			// re(teacher, Pos, m, week, [], S.action );
			q.enqueue({ ...rootVertix, callTo: "re", Action: S.action });
			break;
		case 6: // t!=='' & r!==-1 & a ==='shift'
			q.enqueue({
				...rootVertix,
				callTo: "pivotTo",
				pivotArgs: {
					next_m: S.r,
					AfterReChainNode: {
						...rootVertix,
						callTo: "re",
						Action: S.action,
					},
					beforeReChainNode: null,
				},
			});
			break;
		case 7: // t!=='' & r===-1 & a ==='cycle'
			q.enqueue({
				...rootVertix,
				callTo: "re",
				Action: S.action,
				cycleClosingParentName: rootVertix.teacher,
			});
			break;
		case 8: // t!=='' & r!==-1 & a ==='cycle'
			q.enqueue({
				...rootVertix,
				callTo: "pivotTo",
				pivotArgs: {
					next_m: S.r,
					AfterReChainNode: {
						...rootVertix,
						callTo: "re",
						parent: undefined,
						cycleClosingParentName: rootVertix.teacher,
						Action: S.action,
					},
					beforeReChainNode: null,
				},
			});
			break;
	}
	while (q.notEmpty() && !enoughSolutions(week, justOne)) {
		if (blowout && q.length() > 110) {
			console.log("blowout");
			blowout && blowout(q.queue._store.slice(0, 100));
			// remove first 100 elements from q.queue._store
			q.queue._store.splice(0, 100);
		}
		q.callFront(re, pre, pivotTo);
		q.dequeue();
	}
	q.unlock();
	q.eraseAll();
};

export const someHowPutHimAt = (
	m: number,
	teacher: string,
	Pos: PosType,
	week: IWEEK_GLOBAL_Object,
	freeze: boolean = true,
	iterativeSolutionPoster?: (changes: IActlistObj[]) => void,
	justOne: boolean = false,
	blowout?: blowoutFunction
): void => {
	/*
	* discription*
	for each teacher available here in the original list in this cell
	for each pos in the shared postihions
	if the other teacher is in a pos in the shared one's just do a simple switch or promt for choice
	this should be enough?!
	?!
	*/
	//short hands
	week.Swapping = true;
	// week.HandyAny.beforeAction = [];
	// for (let i = 0; i < week.allClasses.length; i++) {
	// 	let acc = 0;
	// 	// Object.keys(week.allClasses[i].teachers).forEach(
	// 	// 	(teacher)=>{
	// 	// 	  acc = acc + week.allClasses[i].teachers[teacher].remPeriods;
	// 	// 	}
	// 	//   );
	// 	loopOverClass((u, v) => {
	// 		if (week.allClasses[i].l[u][v].currentTeacher === "") acc += 1;
	// 	});
	// 	week.HandyAny.beforeAction.push(acc);
	// }
	// week.HandyAny.test = () => {
	// 	if (week.HandyAny.beforeAction.length !== 0) {
	// 		console.log(week.HandyAny.beforeAction);
	// 	} else {
	// 		console.log("nothing");
	// 	}
	// 	week.HandyAny.beforeAction = [];
	// 	for (let i = 0; i < week.allClasses.length; i++) {
	// 		let acc = 0;
	// 		// Object.keys(week.allClasses[i].teachers).forEach(
	// 		// 	(teacher)=>{
	// 		// 	  acc = acc + week.allClasses[i].teachers[teacher].remPeriods;
	// 		// 	}
	// 		//   );
	// 		loopOverClass((u, v) => {
	// 			if (week.allClasses[i].l[u][v].currentTeacher === "") acc += 1;
	// 		});
	// 		week.HandyAny.beforeAction.push(acc);
	// 	}
	// 	console.log("became");
	// 	console.log(week.HandyAny.beforeAction);
	// };
	//   console.time('delegate')
	delegate(teacher, Pos, m, week, justOne, blowout);
	//   console.timeEnd('delegate')
	// if (week.activateList.length > 0) {
	// 	const ms: number[] = [];
	// 	week.activateList[week.currentSolutionNumber].forEach((step) => {
	// 		let in_ms = false;
	// 		for (let i = 0; i < ms.length; i++) {
	// 			if (ms[i] === step.m) {
	// 				in_ms = true;
	// 				break;
	// 			}
	// 		}
	// 		if (!in_ms) {
	// 			ms.push(step.m);
	// 		}
	// 	});
	// 	week.HandyAny.validate = (week: IWEEK_GLOBAL_Object) => {
	// 		ms.forEach((m) => {
	// 			let dict: any = {};
	// 			const Class = week.allClasses[m];
	// 			loopOverClass((i, j) => {
	// 				const t = Class.l[i][j].currentTeacher;
	// 				if (dict[t] === undefined) {
	// 					dict[t] = 1;
	// 				} else {
	// 					dict[t] += 1;
	// 				}
	// 			});
	// 			Object.keys(dict).forEach((key) => {
	// 				if (key !== "" && dict[key] > Class.teachers[key].Periods) {
	// 					console.log(`m : ${m} and the teacher is ${key}`);
	// 					// eslint-disable-next-line no-throw-literal
	// 					throw "shit";
	// 				}
	// 			});
	// 			console.log("allz good validated!!");
	// 		});
	// 		loopOverClass((i: number, j: number) => {
	// 			for (let mi = 0; mi < week.allClasses.length; mi++) {
	// 				let dict: any = {};
	// 				if (dict[week.allClasses[mi].l[i][j].currentTeacher] !== undefined) {
	// 					console.log(
	// 						`${
	// 							week.allClasses[mi].l[i][j].currentTeacher
	// 						} is at two places at once ${mi} and ${
	// 							dict[week.allClasses[mi].l[i][j].currentTeacher]
	// 						}`
	// 					);
	// 					throw "damit";
	// 				} else {
	// 					dict[week.allClasses[mi].l[i][j].currentTeacher] = mi;
	// 				}
	// 			}
	// 		});
	// 	};
	// 	week.HandyAny.runTests = () => {
	// 		console.log(
	// 			week.activateList[week.currentSolutionNumber].map((item) =>
	// 				JSON.stringify(item)
	// 			)
	// 		);
	// 		week.HandyAny.test();
	// 		week.HandyAny.validate(week);
	// 	};
	// }
	if (!freeze) {
		Done(m, week, iterativeSolutionPoster)({});
	}

	week.forceUpdate && week.forceUpdate();
};
export const Done = (
	m: number,
	week: IWEEK_GLOBAL_Object,
	iterativeSolutionPoster?: (changes: IActlistObj[]) => void
) => {
	return (e: any) => {
		const sol = week.activateList[week.currentSolutionNumber];
		if (sol === undefined) {
			week.Swapping = false;
			week.activateList = [];
			week.currentSolutionNumber = 0;
			week.forceUpdate && week.forceUpdate();
			return;
		}
		iterativeSolutionPoster && iterativeSolutionPoster(sol);
		for (let i = 0; i < sol.length; i++) {
			putHimAt(week, sol[i].m, sol[i].teacher, sol[i].Pos, "remove");
		}
		for (let i = 0; i < sol.length; i++) {
			putHimAt(week, sol[i].m, sol[i].teacher, sol[i].Pos, "put");
		}

		week.Swapping = false;
		week.activateList = [];
		week.currentSolutionNumber = 0;
		week.forceUpdate && week.forceUpdate();
	};
};

/*
<sc<script></script><script>alert('hi');</sc<script></script><script>
<<ss >script>alert('hi');<<ss >/script>
*/
